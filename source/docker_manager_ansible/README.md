# Docker контейнер как управляющий узел

Это кратенькая заметочка, поскольку в конечном счете всё будет выглядеть иначе. Сейчас - промежуточная станция.

Итак, **Dockerfile** содержит приблизительно верные инструкции. Есть сомнения, что все нужные пакеты поставляются, но это уже на деле будем тестить. После установки пакетов создается юзер и чистятся ключи, сгенерированные при установке *openssh-server*. Точка входа - скрипт, смотрит на переданные параметры. Если, например, мы передаем  **SSH_AUTHORIZED_KEY**, он импортирует их в систему. После - старт сервиса *sshd*. 

**docker-compose** содержит инструкции по запуску мостовой сетки для 1 контейнера (нам больше не нужно) и передаваемые выше указанные переменные. Точнее, их объявление. Передаются они в рядом лежащем файле **.env** вида:

```ini
SSH_AUTHORIZED_KEY="открытый ключ..."
```

Примечание: конечно же свой открытый ключ я запихаю в .gitignore, ибо а зачем он в репе?!

Таким образом, мы можем:

```bash
docker build -t ansible:ssh .  # собрать образ

docker compose up  # классически поднять образ # или
docker compose up -d  # поднять в фоне  # или
docker compose up --force-recreate  # насильно пересоздать и поднять образ
```

Как бы то ни было, ssh ключи оправлены, поэтому можно безболезненно коннектиться:

```bash
ssh ubuntu@localhost -p 40003
```

> Напоминашка:
>
> ```bash
> docker ps -a
> docker rm id
> docker image -ls
> docker rmi id
> docker compose rm -fsv  # удалить все контейнеры с томами в рамках compose
> ```

## Что не сделано?

В планах:

2. Предоставить приватный ключ;
3. Запихать в playbook. Старт, стоп, пересборка - удобно. Зачем всякие там команды помнить и что-то документировать?!;
4. Возможно, запихать на докер хаб. Возможно. Это не очень-то приоритетная задача...